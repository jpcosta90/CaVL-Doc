
import json
import os

NOTEBOOK_PATH = "analysis/01_architecture_analysis.ipynb"

# The visualization code to inject
VIZ_CODE = [
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.patches as patches\n",
    "import numpy as np\n",
    "import os\n",
    "\n",
    "def draw_aligned_figure():\n",
    "    # Vertical Alignment: 2 Rows, 1 Column\n",
    "    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 7))\n",
    "    plt.subplots_adjust(hspace=0.4, top=0.95, bottom=0.05, left=0.02, right=0.98)\n",
    "\n",
    "    # Styles\n",
    "    COLOR_BG_GEN = '#fff5f5'   # Faint Red/Warm\n",
    "    COLOR_BG_OURS = '#f0f9f0'  # Faint Green/Cool\n",
    "    COLOR_BORDER_GEN = '#e6b8af'\n",
    "    COLOR_BORDER_OURS = '#b6d7a8'\n",
    "    \n",
    "    COLOR_MODEL_GEN = {'face': '#e1d5e7', 'edge': '#9673a6'} # Purple\n",
    "    COLOR_MODEL_OURS = {'face': '#d5e8d4', 'edge': '#82b366'} # Green\n",
    "    \n",
    "    FONT_SIZE_BODY = 10\n",
    "\n",
    "    def draw_box(ax, x, y, w, h, text, style, subtext=None, alpha=1.0, zorder=2, fontsize=None):\n",
    "        if fontsize is None: fontsize = FONT_SIZE_BODY\n",
    "        box = patches.FancyBboxPatch((x, y), w, h, boxstyle=\"round,pad=0.1\", \n",
    "                                     linewidth=1.5, edgecolor=style['edge'], facecolor=style['face'], \n",
    "                                     alpha=alpha, zorder=zorder)\n",
    "        ax.add_patch(box)\n",
    "        ax.text(x + w/2, y + h/2, text, ha='center', va='center', \n",
    "                fontsize=fontsize, fontweight='bold', color='#333333', zorder=zorder+1)\n",
    "        if subtext:\n",
    "             ax.text(x + w/2, y + h/2 - 0.35, subtext, ha='center', va='top', \n",
    "                     fontsize=fontsize-2, color='#555555', zorder=zorder+1)\n",
    "        return box\n",
    "\n",
    "    def draw_arrow(ax, start, end, color='#555555'):\n",
    "        ax.annotate(\"\", xy=end, xytext=start, arrowprops=dict(arrowstyle=\"->\", lw=1.5, color=color))\n",
    "\n",
    "    def draw_doc_stack(ax, x, y, w, h):\n",
    "        # Draw a stack of 3 documents within rectangular bounds w,h\n",
    "        # Center it visually around x + w/2\n",
    "        doc_w, doc_h = w * 0.8, h * 0.9\n",
    "        start_x = x + (w - doc_w)/2\n",
    "        start_y = y + (h - doc_h)/2\n",
    "        \n",
    "        for i in range(3):\n",
    "            offset = i * 0.08\n",
    "            rect = patches.Rectangle((start_x + offset, start_y + offset), doc_w, doc_h, linewidth=1, edgecolor='#999', facecolor='white', zorder=2+i)\n",
    "            ax.add_patch(rect)\n",
    "            for line_y in [0.75, 0.55, 0.35, 0.15]:\n",
    "                ax.plot([start_x + offset + 0.1, start_x + offset + doc_w - 0.1], \n",
    "                        [start_y + offset + line_y*doc_h, start_y + offset + line_y*doc_h], color='#ccc', lw=1, zorder=3+i)\n",
    "        ax.text(x + w/2, y - 0.25, \"Input Docs\", ha='center', fontsize=9, color='#555')\n",
    "\n",
    "    # ==========================================\n",
    "    # Layout Logic\n",
    "    # ==========================================\n",
    "    # We define X standard positions to ensure perfect alignments\n",
    "    # Total width approx 12 units\n",
    "    \n",
    "    X_START = 0.5\n",
    "    W_DOC = 1.2\n",
    "    GAP_1 = 1.0\n",
    "    W_MODEL = 2.8\n",
    "    GAP_2 = 1.0\n",
    "    X_OUTPUT = X_START + W_DOC + GAP_1 + W_MODEL + GAP_2 # Start of output section\n",
    "    \n",
    "    Y_CENTER_A = 1.6\n",
    "    Y_CENTER_B = 1.6\n",
    "    \n",
    "    # ==========================================\n",
    "    # PANEL A: Generative Model\n",
    "    # ==========================================\n",
    "    ax1.set_xlim(0, 12)\n",
    "    ax1.set_ylim(0, 3.2)\n",
    "    ax1.axis('off')\n",
    "    \n",
    "    # Container\n",
    "    container_a = patches.FancyBboxPatch((0.2, 0.2), 11.6, 2.5, boxstyle=\"round,pad=0.1\", \n",
    "                                         linewidth=1.5, edgecolor=COLOR_BORDER_GEN, facecolor=COLOR_BG_GEN, zorder=0)\n",
    "    ax1.add_patch(container_a)\n",
    "    ax1.set_title(\"(A) Multimodal Generative Model\", loc='left', fontsize=11, fontweight='bold', color='#c0392b', pad=5)\n",
    "\n",
    "    # 1. Docs\n",
    "    draw_doc_stack(ax1, X_START, Y_CENTER_A - 0.6, W_DOC, 1.2)\n",
    "\n",
    "    # Arrow 1\n",
    "    x_arrow1_start = X_START + W_DOC + 0.1 # Small padding\n",
    "    x_arrow1_end = X_START + W_DOC + GAP_1 - 0.1\n",
    "    draw_arrow(ax1, (x_arrow1_start, Y_CENTER_A), (x_arrow1_end, Y_CENTER_A))\n",
    "\n",
    "    # 2. Model\n",
    "    draw_box(ax1, X_START + W_DOC + GAP_1, Y_CENTER_A - 0.7, W_MODEL, 1.4, \n",
    "             \"Multimodal\\nLLM\", COLOR_MODEL_GEN, subtext=\"(Autoregressive)\", fontsize=9)\n",
    "             \n",
    "    # Arrow 2\n",
    "    x_arrow2_start = X_START + W_DOC + GAP_1 + W_MODEL + 0.1\n",
    "    x_arrow2_end = X_OUTPUT - 0.1\n",
    "    draw_arrow(ax1, (x_arrow2_start, Y_CENTER_A), (x_arrow2_end, Y_CENTER_A))\n",
    "\n",
    "    # 3. Sequential Output\n",
    "    # We draw tokens starting exactly at X_OUTPUT\n",
    "    tokens = [\"<class>\", \"Invoice\", \"<EOS>\"]\n",
    "    for i, t in enumerate(tokens):\n",
    "        y_pos = Y_CENTER_A + 0.5 - i * 0.55\n",
    "        draw_box(ax1, X_OUTPUT, y_pos, 1.4, 0.45, t, {'face': '#fff2cc', 'edge': '#d6b656'}, fontsize=8)\n",
    "        # Connectors\n",
    "        if i < len(tokens) - 1:\n",
    "             draw_arrow(ax1, (X_OUTPUT + 0.7, y_pos), (X_OUTPUT + 0.7, y_pos - 0.1))\n",
    "             \n",
    "    ax1.text(X_OUTPUT + 1.6, Y_CENTER_A, \"Sequential Output\\nHigh Latency\", ha='left', va='center', fontsize=9, color='#666')\n",
    "\n",
    "\n",
    "    # ==========================================\n",
    "    # PANEL B: CaVL-Doc Approach\n",
    "    # ==========================================\n",
    "    ax2.set_xlim(0, 12)\n",
    "    ax2.set_ylim(0, 3.2)\n",
    "    ax2.axis('off')\n",
    "\n",
    "    # Container\n",
    "    container_b = patches.FancyBboxPatch((0.2, 0.2), 11.6, 2.5, boxstyle=\"round,pad=0.1\", \n",
    "                                         linewidth=1.5, edgecolor=COLOR_BORDER_OURS, facecolor=COLOR_BG_OURS, zorder=0)\n",
    "    ax2.add_patch(container_b)\n",
    "    ax2.set_title(\"(B) CaVL-Doc (Ours)\", loc='left', fontsize=11, fontweight='bold', color='#2e7d32', pad=5)\n",
    "\n",
    "    # 1. Docs\n",
    "    draw_doc_stack(ax2, X_START, Y_CENTER_B - 0.6, W_DOC, 1.2)\n",
    "\n",
    "    # Arrow 1\n",
    "    draw_arrow(ax2, (x_arrow1_start, Y_CENTER_B), (x_arrow1_end, Y_CENTER_B))\n",
    "\n",
    "    # 2. Model\n",
    "    draw_box(ax2, X_START + W_DOC + GAP_1, Y_CENTER_B - 0.7, W_MODEL, 1.4, \n",
    "             \"Multimodal\\nEncoder\", COLOR_MODEL_OURS, subtext=\"(Frozen ViT)\", fontsize=9)\n",
    "\n",
    "    # Arrow 2\n",
    "    draw_arrow(ax2, (x_arrow2_start, Y_CENTER_B), (x_arrow2_end, Y_CENTER_B))\n",
    "\n",
    "    # 3. Metric Space Output\n",
    "    # Circle centered at X_OUTPUT + radius\n",
    "    radius = 1.0\n",
    "    center_x = X_OUTPUT + radius\n",
    "    circle = patches.Circle((center_x, Y_CENTER_B), radius, facecolor='white', edgecolor='#999', linestyle='--', zorder=1)\n",
    "    ax2.add_patch(circle)\n",
    "    \n",
    "    # Points inside circle\n",
    "    ax2.scatter([center_x - 0.3, center_x + 0.3, center_x - 0.1], \n",
    "                [Y_CENTER_B + 0.2, Y_CENTER_B + 0.1, Y_CENTER_B - 0.3], c='#ccc', s=30)\n",
    "    ax2.scatter([center_x + 0.1], [Y_CENTER_B], c='#d79b00', edgecolors='black', s=80, marker='*', zorder=5)\n",
    "\n",
    "    ax2.text(center_x + radius + 0.2, Y_CENTER_B, \"Metric Proximity\\nLow Latency O(1)\", ha='left', va='center', fontsize=9, color='#2e7d32', fontweight='bold')\n",
    "\n",
    "    plt.tight_layout()\n",
    "    \n",
    "    # Save\n",
    "    output_path = \"../docs/assets/teaser_fig.pdf\"\n",
    "    output_dir = os.path.dirname(output_path)\n",
    "    os.makedirs(output_dir, exist_ok=True)\n",
    "    print(f\"Saving aligned figure to {output_path}\")\n",
    "    plt.savefig(output_path, dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "draw_aligned_figure()"
]

new_cell = {
    "cell_type": "code",
    "execution_count": None,
    "id": "teaser_figure_gen_aligned",
    "metadata": {},
    "outputs": [],
    "source": VIZ_CODE
}

def main():
    if not os.path.exists(NOTEBOOK_PATH):
        print(f"Error: {NOTEBOOK_PATH} not found.")
        return

    with open(NOTEBOOK_PATH, 'r') as f:
        nb_data = json.load(f)

    # Clean old cells\
    nb_data['cells'] = [c for c in nb_data['cells'] if "vertical" not in "".join(c['source']) and "polished" not in "".join(c['source']) and "compact" not in "".join(c['source']) and "conceptual" not in "".join(c['source']) and "aligned" not in "".join(c['source'])]

    # Append new refined cell
    nb_data['cells'].append(new_cell)
    print("Appending new Aligned visualization cell...")

    with open(NOTEBOOK_PATH, 'w') as f:
        json.dump(nb_data, f, indent=1)
    
    print(f"Successfully updated {NOTEBOOK_PATH}")

if __name__ == "__main__":
    main()
